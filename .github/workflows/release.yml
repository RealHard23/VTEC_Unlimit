name: Update Repository from Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v4.3.0)'
        required: false
        default: 'latest'

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get release info
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            let release;
            
            try {
              if (context.eventName === 'workflow_dispatch' && github.event.inputs.version && github.event.inputs.version !== 'latest') {
                // Manual trigger with specific version
                console.log('Getting release by tag:', github.event.inputs.version);
                const { data: specificRelease } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: github.event.inputs.version
                });
                release = specificRelease;
              } else {
                // Auto trigger or latest
                console.log('Getting latest release...');
                const { data: latestRelease } = await github.rest.repos.getLatestRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                release = latestRelease;
              }
            } catch (error) {
              if (error.status === 404) {
                console.log('No latest release found, getting all releases...');
                
                const { data: releases } = await github.rest.repos.listReleases({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 20
                });
                
                console.log('Found releases:', releases.map(r => ({ 
                  tag: r.tag_name, 
                  draft: r.draft, 
                  prerelease: r.prerelease,
                  assets: r.assets.length
                })));
                
                // Find first published release with assets
                const publishedRelease = releases.find(r => 
                  !r.draft && 
                  !r.prerelease && 
                  r.assets.length > 0
                );
                
                if (!publishedRelease) {
                  throw new Error('âŒ No published releases found with assets. Please:\n1. Create a release\n2. Upload a .zip file\n3. Make sure it\'s not a draft or pre-release');
                }
                
                release = publishedRelease;
              } else {
                throw error;
              }
            }
            
            console.log('Using release:', release.tag_name);
            console.log('Release assets:', release.assets.map(a => a.name));
            
            // Find zip file in assets
            const zipAsset = release.assets.find(asset => 
              asset.name.endsWith('.zip')
            );
            
            if (!zipAsset) {
              throw new Error('âŒ No .zip file found in release assets. Please upload a .zip file to the release.');
            }
            
            console.log('Found zip file:', zipAsset.name);
            
            core.setOutput('version', release.tag_name);
            core.setOutput('zip_url', zipAsset.browser_download_url);
            core.setOutput('zip_name', zipAsset.name);
            core.setOutput('release_body', release.body || '');
            
            return {
              version: release.tag_name,
              zipUrl: zipAsset.browser_download_url,
              zipName: zipAsset.name,
              releaseBody: release.body || ''
            };

      - name: Extract version info
        id: version_info
        run: |
          VERSION="${{ steps.release.outputs.version }}"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          
          # Extract version code from version (e.g., v4.2.1 -> 421)
          VERSION_NUMBER=$(echo "$VERSION" | sed 's/v//')
          MAJOR=$(echo "$VERSION_NUMBER" | cut -d'.' -f1)
          MINOR=$(echo "$VERSION_NUMBER" | cut -d'.' -f2)
          PATCH=$(echo "$VERSION_NUMBER" | cut -d'.' -f3)
          
          # Handle missing patch version
          if [ -z "$PATCH" ]; then
            PATCH=0
          fi
          
          VERSION_CODE=$((MAJOR * 100 + MINOR * 10 + PATCH))
          
          echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
          echo "âœ… Version: $VERSION"
          echo "âœ… Version Code: $VERSION_CODE"

      - name: Download and extract zip
        run: |
          echo "ðŸ”½ Downloading zip file..."
          wget -O temp_module.zip "${{ steps.release.outputs.zip_url }}"
          
          echo "ðŸ“¦ Extracting zip file..."
          mkdir -p temp_extract
          unzip -q temp_module.zip -d temp_extract/
          
          echo "ðŸ“‹ Extracted contents:"
          find temp_extract -type f | head -20

      - name: Update module.prop
        run: |
          echo "ðŸ”„ Updating module.prop..."
          
          if [ -f "temp_extract/module.prop" ]; then
            # Use module.prop from zip as base
            cp temp_extract/module.prop module.prop
          elif [ ! -f "module.prop" ]; then
            echo "âŒ No module.prop found in zip or repository!"
            exit 1
          fi
          
          # Backup
          cp module.prop module.prop.bak
          
          # Update version and versionCode
          if grep -q "^version=" module.prop; then
            sed -i "s/^version=.*/version=$VERSION/" module.prop
          else
            echo "version=$VERSION" >> module.prop
          fi
          
          if grep -q "^versionCode=" module.prop; then
            sed -i "s/^versionCode=.*/versionCode=$VERSION_CODE/" module.prop
          else
            echo "versionCode=$VERSION_CODE" >> module.prop
          fi
          
          echo "âœ… Updated module.prop:"
          cat module.prop

      - name: Update update.json
        run: |
          echo "ðŸ”„ Updating update.json..."
          
          cat << EOF > update.json
          {
            "version": "$VERSION",
            "versionCode": "$VERSION_CODE",
            "zipUrl": "${{ steps.release.outputs.zip_url }}",
            "changelog": "https://raw.githubusercontent.com/${{ github.repository }}/main/changelog.md"
          }
          EOF
          
          echo "âœ… Created update.json:"
          cat update.json

      - name: Update changelog
        run: |
          echo "ðŸ“ Updating changelog..."
          
          # Create changelog if not exists
          if [ ! -f "changelog.md" ]; then
            echo "# Changelog" > changelog.md
            echo "" >> changelog.md
          fi
          
          # Check if version already exists
          if ! grep -q "## $VERSION" changelog.md; then
            temp_file=$(mktemp)
            echo "# Changelog" > "$temp_file"
            echo "" >> "$temp_file"
            echo "## $VERSION ($(date +%Y-%m-%d))" >> "$temp_file"
            echo "- Updated to version $VERSION" >> "$temp_file"
            echo "- Version code: $VERSION_CODE" >> "$temp_file"
            
            # Add release notes if available
            RELEASE_BODY="${{ steps.release.outputs.release_body }}"
            if [ -n "$RELEASE_BODY" ]; then
              echo "- Release notes:" >> "$temp_file"
              echo "$RELEASE_BODY" | sed 's/^/  /' >> "$temp_file"
            fi
            
            echo "" >> "$temp_file"
            
            # Append existing content
            if [ -f "changelog.md" ]; then
              tail -n +2 changelog.md >> "$temp_file"
            fi
            
            mv "$temp_file" changelog.md
            echo "âœ… Updated changelog.md"
          else
            echo "â„¹ï¸ Version $VERSION already exists in changelog"
          fi

      - name: Update README
        run: |
          echo "ðŸ“– Updating README..."
          
          if [ -f "README.md" ]; then
            cp README.md README.md.bak
            
            # Update version patterns
            sed -i "s/v[0-9]\+\.[0-9]\+\.[0-9]\+/$VERSION/g" README.md
            sed -i "s/Version: v[0-9]\+\.[0-9]\+\.[0-9]\+/Version: $VERSION/g" README.md
            sed -i "s/Latest: v[0-9]\+\.[0-9]\+\.[0-9]\+/Latest: $VERSION/g" README.md
            sed -i "s/Version Code: [0-9]\+/Version Code: $VERSION_CODE/g" README.md
            
            # Update download URLs
            sed -i "s|https://github.com/.*/releases/download/v[0-9]\+\.[0-9]\+\.[0-9]\+/.*\.zip|${{ steps.release.outputs.zip_url }}|g" README.md
            
            echo "âœ… Updated README.md"
          else
            echo "â„¹ï¸ README.md not found, skipping"
          fi

      - name: Update other files
        run: |
          echo "ðŸ”„ Updating other files..."
          
          # Update JSON files
          for file in *.json; do
            if [ -f "$file" ] && [ "$file" != "update.json" ]; then
              if grep -q "version" "$file"; then
                echo "Updating $file"
                sed -i "s/\"version\": \"v[0-9]\+\.[0-9]\+\.[0-9]\+\"/\"version\": \"$VERSION\"/g" "$file"
                sed -i "s/\"versionCode\": \"[0-9]\+\"/\"versionCode\": \"$VERSION_CODE\"/g" "$file"
              fi
            fi
          done
          
          # Update text files
          for file in *.txt; do
            if [ -f "$file" ]; then
              if grep -q "v[0-9]\+\.[0-9]\+\.[0-9]\+" "$file"; then
                echo "Updating $file"
                sed -i "s/v[0-9]\+\.[0-9]\+\.[0-9]\+/$VERSION/g" "$file"
              fi
            fi
          done

      - name: Commit changes
        run: |
          echo "ðŸ’¾ Committing changes..."
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add all changes
          git add .
          
          # Check for changes
          if git diff --staged --quiet; then
            echo "â„¹ï¸ No changes to commit"
          else
            git commit -m "ðŸš€ Auto-update to $VERSION [skip ci]

            ðŸ“¦ Updated files:
            - module.prop (version: $VERSION, versionCode: $VERSION_CODE)
            - update.json (zipUrl: ${{ steps.release.outputs.zip_url }})
            - changelog.md
            - README.md
            
            ðŸ”— Release: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
            
            git push
            echo "âœ… Changes committed and pushed"
          fi

      - name: Cleanup
        run: |
          echo "ðŸ§¹ Cleaning up..."
          rm -rf temp_extract temp_module.zip *.bak 2>/dev/null || true

      - name: Success summary
        run: |
          echo "ðŸŽ‰ SUCCESS! Repository updated successfully"
          echo ""
          echo "ðŸ“‹ Summary:"
          echo "  Version: $VERSION"
          echo "  Version Code: $VERSION_CODE"
          echo "  Zip URL: ${{ steps.release.outputs.zip_url }}"
          echo "  Zip File: ${{ steps.release.outputs.zip_name }}"
          echo ""
          echo "ðŸ”— Links:"
          echo "  Release: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
          echo "  Repository: https://github.com/${{ github.repository }}"
          echo ""
          echo "âœ… Magisk Manager should now detect the update!"
